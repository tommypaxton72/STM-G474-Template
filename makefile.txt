# ChatGPT created make file thats been fully commented for learning how make works.
#
#
#
#
#

# ================================
# TOOLCHAIN
# ================================

# The C compiler for ARM Cortex-M
CC = arm-none-eabi-gcc

# Used to convert ELF → raw binary for flashing
OBJCOPY = arm-none-eabi-objcopy

# Prints flash / RAM usage info
SIZE = arm-none-eabi-size


# ================================
# TARGET NAME
# ================================

# Base name of output files:
# firmware.elf
# firmware.bin
TARGET = firmware


# ================================
# MCU ARCHITECTURE FLAGS
# ================================

# CPU core used by STM32G474
CPU = -mcpu=cortex-m4

# Hardware floating point unit present on G4
FPU = -mfpu=fpv4-sp-d16

# Use hardware FPU instructions (NOT software emulation)
FLOAT_ABI = -mfloat-abi=hard


# ================================
# COMPILER FLAGS (C → .o)
# ================================

CFLAGS = \
	$(CPU) $(FPU) $(FLOAT_ABI) \
	-mthumb \
	-O0 \
	-g \
	-Wall \
	-ffunction-sections \
	-fdata-sections \
	$(INCLUDES)

# Why sections matter:
# → allows the linker to REMOVE unused code
# → critical in embedded systems


# ================================
# LINKER FLAGS (.o → ELF)
# ================================

LDFLAGS = \
	$(CPU) $(FPU) $(FLOAT_ABI) \
	-mthumb \
	-T linker/STM32G474RETX_FLASH.ld \
	-Wl,--gc-sections

# The linker script decides:
# - Flash start address
# - RAM start address
# - Stack size
# - Where .text, .data, .bss go


# ================================
# INCLUDE PATHS
# ================================

INCLUDES = \
	-Icmsis \
	-Icmsis/Include \
	-Icmsis/Device/system_stm32G4xx \
	-Isrc/drivers


# ================================
# SOURCE FILES
# ================================

SRCS = \
	src/main.c \
	src/drivers/rcc.c \
	src/drivers/gpio.c \
	cmsis/device/stm32g4xx/system_stm32g4xx.c \
	startup/startup_stm32g474xx.s


# main.c → your code
# system_stm32g4xx.c → clock + SystemInit()
# startup_stm32g474xx.s → vector table + reset handler


# ================================
# OBJECT FILE GENERATION
# ================================

# Convert .c → .o
OBJS = $(SRCS:.c=.o)

# Convert .s → .o
OBJS := $(OBJS:.s=.o)


# ================================
# BUILD RULES
# ================================

# Default target when you run `make`
all: $(TARGET).elf $(TARGET).bin


# Link all object files into an ELF
$(TARGET).elf: $(OBJS)
	$(CC) $(OBJS) $(LDFLAGS) -o $@
	$(SIZE) $@

# $@ = target name (firmware.elf)
# $(OBJS) = all compiled object files


# Convert ELF → raw binary
$(TARGET).bin: $(TARGET).elf
	$(OBJCOPY) -O binary $< $@

# $< = first dependency (firmware.elf)


# ================================
# CLEAN
# ================================

clean:
	rm -f $(OBJS) $(TARGET).elf $(TARGET).bin
